<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Squid::Tasks: SquidTasks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Squid::Tasks<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">C++14 coroutine-based task library for games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SquidTasks </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md10">Overview of Squid::Tasks</a></li>
<li class="level1"><a href="#autotoc_md11">Integrating Squid::Tasks</a></li>
<li class="level1"><a href="#autotoc_md12">Configuring Squid::Tasks with TasksConfig.h</a></li>
<li class="level1"><a href="#autotoc_md13">An Example First Task</a></li>
<li class="level1"><a href="#autotoc_md14">Next Steps</a></li>
<li class="level1"><a href="#autotoc_md15">Appendices</a><ul><li class="level2"><a href="#autotoc_md16">APPENDIX A: Enabling Global Time Support</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md10"></a>
Overview of Squid::Tasks</h1>
<p >Squid::Tasks is a header-only library consisting of several top-level headers within the include directory.</p>
<ul>
<li><code><a class="el" href="_task_8h_source.html">Task.h</a></code> - Task-handles and standard awaiters [REQUIRED]</li>
<li><code><a class="el" href="_task_manager_8h_source.html">TaskManager.h</a></code> - Manager that runs and resumes a collection of tasks</li>
<li><code><a class="el" href="_token_list_8h_source.html">TokenList.h</a></code> - Data structure for tracking decentralized state across multiple tasks</li>
<li><code><a class="el" href="_function_guard_8h_source.html">FunctionGuard.h</a></code> - Scope guard that calls a function as it leaves scope</li>
<li><code><a class="el" href="_task_f_s_m_8h_source.html">TaskFSM.h</a></code> - Finite state machine that implements states using task factories</li>
</ul>
<p >Sample projects can be found under the <code>/samples</code> directory.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Integrating Squid::Tasks</h1>
<p >The steps for integrating Squid::Tasks into your game depends on how your game is built:</p>
<ul>
<li>Integrating Squid::Tasks into an Unreal Engine 4 project</li>
<li>Integrating Squid::Tasks into an Unreal Engine 5 project</li>
<li>Integrating Squid::Tasks into a standalone Visual Studio project</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Configuring Squid::Tasks with TasksConfig.h</h1>
<p >The Squid::Tasks library can be configured in a variety of important ways. This is done by enabling and disabling preprocessor values within the <a class="el" href="_tasks_config_8h_source.html">include/TasksConfig.h</a> file:</p>
<ul>
<li><b>SQUID_ENABLE_TASK_DEBUG</b>: Enables <a class="el" href="class_task.html">Task</a> debug callstack tracking and debug names via <a class="el" href="class_task.html#a4a530d3e0b7af84931ef01c0ee59644a" title="Gets this task&#39;s debug stack (use TASK_NAME to set a task&#39;s debug name)">Task::GetDebugStack()</a> and <a class="el" href="class_task.html#a91bb217ee145611bf69bab48eb5b57ae" title="Gets this task&#39;s debug name (use TASK_NAME to set the debug name)">Task::GetDebugName()</a></li>
<li><b>SQUID_ENABLE_DOUBLE_PRECISION_TIME</b>: Switches time representation from 32-bit single-precision floats to 64-bit double-precision floats</li>
<li><b>SQUID_ENABLE_NAMESPACE</b>: Enables a Squid:: namespace around all classes in the Squid::Tasks library</li>
<li><b>SQUID_USE_EXCEPTIONS</b>: Enables experimental (largely-untested) exception-handling, and replaces all asserts with runtime_error exceptions</li>
<li><b>SQUID_ENABLE_GLOBAL_TIME</b>: Enables global time support (alleviating the need to specify a time stream for time-sensitive awaiters) <b>[see Appendix A for more details]</b></li>
</ul>
<h1><a class="anchor" id="autotoc_md13"></a>
An Example First Task</h1>
<p >To get started using Squid::Tasks, the first step is to write and execute your first task from within your project. Many modern C++ game engines feature some sort of "actor" class - a game entity that exists within the scene and is updated each frame. Our example code assume this class exists, but the same principles will apply for projects that are written under a different paradigm.</p>
<p >The first step is to identify an actor class that would benefit from coroutine support, such as an enemy actor. Here is an example Enemy class from a hypothetical 2D game:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Enemy : <span class="keyword">public</span> Actor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> SetRotation(<span class="keywordtype">float</span> in_degrees); <span class="comment">// Set the rotation of the enemy</span></div>
<div class="line">    <span class="keywordtype">float</span> GetRotation() <span class="keyword">const</span>; <span class="comment">// Get the rotation of the enemy</span></div>
<div class="line">    <span class="keywordtype">void</span> SetPosition(Vec2f in_pos); <span class="comment">// Set the position of the enemy</span></div>
<div class="line">    Vec2f GetPosition() <span class="keyword">const</span>; <span class="comment">// Get the position of th enemy</span></div>
<div class="line">    <span class="keywordtype">void</span> MoveToward(Vec2f in_pos, <span class="keywordtype">float</span> in_speed, <span class="keywordtype">float</span> in_dt) <span class="keyword">const</span>; <span class="comment">// Move toward a target position at a given speed</span></div>
<div class="line">    <span class="keywordtype">void</span> FireProjectileAt(Vec2f in_pos); <span class="comment">// Fire a simple projectile to a target position</span></div>
<div class="line">    std::shared_ptr&lt;Player&gt; GetPlayer() <span class="keyword">const</span>; <span class="comment">// Get the location of the player actor</span></div>
<div class="line">    <span class="keywordtype">float</span> GameTime() <span class="keyword">const</span>; <span class="comment">// Get the current game time (in seconds)</span></div>
<div class="line">    <span class="keywordtype">float</span> DeltaTime() <span class="keyword">const</span>; <span class="comment">// Get the current frame&#39;s delta-time (in seconds)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnInitialize() override <span class="comment">// Automatically called when this enemy enters the scene</span></div>
<div class="line">    {</div>
<div class="line">        Actor::OnInitialize(); <span class="comment">// Call the base Actor function</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tick(<span class="keywordtype">float</span> in_dt) <span class="keyword">override</span> <span class="comment">// Automatically called every frame</span></div>
<div class="line">    {</div>
<div class="line">        Actor::Tick(in_dt); <span class="comment">// Call the base Actor function</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnDestroy() override <span class="comment">// Automatically called when this enemy leaves the scene</span></div>
<div class="line">    {</div>
<div class="line">        Actor::OnDestroy(); <span class="comment">// Call the base Actor function</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p >We want to try writing a simple enemy AI using Squid::Tasks. Conventionally, the <code>Tick()</code> function would be responsible for performing all AI logic calculations, so we will use that as the entry-point into our first task coroutine. First, we will create a <code><a class="el" href="class_task_manager.html" title="Manager that runs and resumes a collection of tasks.">TaskManager</a></code> as a private member m_taskMgr. Then, we call <code>m_taskMgr.Update()</code> from within <code>Tick()</code>. Lastly, we need to make sure all of tasks stop running as soon as the enemy leaves the scene, so we call <code>m_taskMgr.KillAllTasks()</code> from within <code>OnDestroy()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Enemy : <span class="keyword">public</span> Actor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tick(<span class="keywordtype">float</span> in_dt) <span class="keyword">override</span> <span class="comment">// Automatically called every frame</span></div>
<div class="line">    {</div>
<div class="line">        Actor::Tick(in_dt); <span class="comment">// Call the base Actor function</span></div>
<div class="line">        m_taskMgr.Update(); <span class="comment">// Resume all active tasks once per tick</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnDestroy() override <span class="comment">// Automatically called when this enemy leaves the scene</span></div>
<div class="line">    {</div>
<div class="line">        m_taskMgr.KillAllTasks(); <span class="comment">// Kill all active tasks when we leave the scene</span></div>
<div class="line">        Actor::OnDestroy(); <span class="comment">// Call the base Actor function</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    TaskManage m_taskMgr;</div>
<div class="line">};</div>
</div><!-- fragment --><p >Now that we have the task manager hooked up, we can write and run our first task. Let's make our first task very simple, and just have it print out a string and then terminate. To create a task, we simply write a member function with returns type <code><a class="el" href="class_task.html">Task</a>&lt;&gt;</code>, and make sure to use at least one co_await or co_return keyword within the function body. This tells the compiler to compile the function as a coroutine with Task&lt;&gt; as the handle type for the coroutine.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Enemy : <span class="keyword">public</span> Actor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnInitialize() override <span class="comment">// Automatically called when this enemy enters the scene</span></div>
<div class="line">    {</div>
<div class="line">        Actor::OnInitialize(); <span class="comment">// Call the base Actor function</span></div>
<div class="line">        m_taskMgr.RunManaged(ManageEnemyAI()); <span class="comment">// Run our task as a fire-and-forget &quot;managed task&quot;</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_task.html">Task&lt;&gt;</a> ManageEnemyAI()</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_define" href="group___tasks.html#ga690682b65b640b8808e2298590acfdf5">TASK_NAME</a>(__FUNCTION__); <span class="comment">// Gives the task a name for debugging purposes</span></div>
<div class="line"> </div>
<div class="line">        printf(<span class="stringliteral">&quot;Hello, enemy AI!\n&quot;</span>);</div>
<div class="line">        <span class="keyword">co_return</span>; <span class="comment">// Return from this task</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_task_html"><div class="ttname"><a href="class_task.html">Task</a></div><div class="ttdef"><b>Definition:</b> Task.h:204</div></div>
<div class="ttc" id="agroup___tasks_html_ga690682b65b640b8808e2298590acfdf5"><div class="ttname"><a href="group___tasks.html#ga690682b65b640b8808e2298590acfdf5">TASK_NAME</a></div><div class="ttdeci">#define TASK_NAME(...)</div><div class="ttdoc">Macro that instruments a task with a debug name string. Usually at the top of every task coroutine as...</div><div class="ttdef"><b>Definition:</b> Task.h:25</div></div>
</div><!-- fragment --><p >With these changes, any enemy instance that enters the scene will print "Hello, enemy AI!". Note that we actually run the task from within <code>OnInitialize()</code>. This line is what actually instantiates the task and tells the task manager to update it every frame. Now that we have the complete scaffolding in, we can try to write an actual enemy behavior. Let's try writing a simple chase AI that chases the player if they get too close to the enemy.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Enemy : <span class="keyword">public</span> Actor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    </div>
<div class="line">    <a class="code hl_class" href="class_task.html">Task&lt;&gt;</a> ManageEnemyAI()</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_define" href="group___tasks.html#ga690682b65b640b8808e2298590acfdf5">TASK_NAME</a>(__FUNCTION__); <span class="comment">// Gives the task a name for debugging purposes</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span>(<span class="keyword">true</span>) <span class="comment">// This &quot;infinite loop&quot; means this task should run for the enemy&#39;s lifetime</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Wait until player gets within a 100-pixel radius</span></div>
<div class="line">            <span class="keyword">co_await</span> <a class="code hl_function" href="group___awaiters.html#ga844758e35c6f1a45e2254deecdfacf98">WaitUntil</a>([&amp;] {</div>
<div class="line">                <span class="keywordflow">return</span> Distance(GetPlayer()-&gt;GetPosition(), GetPosition()) &lt; 100.0f;</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Move toward the player as long as they are within a 100-pixel radius</span></div>
<div class="line">            <span class="keywordflow">while</span>(Distance(GetPlayer()-&gt;GetPosition(), GetPosition()) &lt; 100.0f)</div>
<div class="line">            {</div>
<div class="line">                MoveToward(GetPlayer()-&gt;GetPosition(), 100.0f, DeltaTime());</div>
<div class="line">                <span class="keyword">co_await</span> <a class="code hl_struct" href="struct_suspend.html">Suspend</a>();</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Cool-down for 2 seconds before following again</span></div>
<div class="line">            <span class="keyword">co_await</span> <a class="code hl_function" href="group___awaiters.html#gad09d1c3766b54864b929aef77424e392">WaitSeconds</a>(2.0f, GameTime());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="agroup___awaiters_html_ga844758e35c6f1a45e2254deecdfacf98"><div class="ttname"><a href="group___awaiters.html#ga844758e35c6f1a45e2254deecdfacf98">WaitUntil</a></div><div class="ttdeci">Task WaitUntil(tTaskReadyFn in_readyFn)</div><div class="ttdoc">Awaiter function that waits until a given functor returns true.</div><div class="ttdef"><b>Definition:</b> Task.h:823</div></div>
<div class="ttc" id="agroup___awaiters_html_gad09d1c3766b54864b929aef77424e392"><div class="ttname"><a href="group___awaiters.html#gad09d1c3766b54864b929aef77424e392">WaitSeconds</a></div><div class="ttdeci">Task&lt; tTaskTime &gt; WaitSeconds(tTaskTime in_seconds, tTimeFn in_timeFn)</div><div class="ttdoc">Awaiter function that waits N seconds in a given time-stream.</div><div class="ttdef"><b>Definition:</b> Task.h:850</div></div>
<div class="ttc" id="astruct_suspend_html"><div class="ttname"><a href="struct_suspend.html">Suspend</a></div><div class="ttdoc">Awaiter class that suspends unconditionally.</div><div class="ttdef"><b>Definition:</b> Task.h:91</div></div>
</div><!-- fragment --><p >Our chase enemy AI is complete! One advantage of coroutines is that they tend to be fairly straightforward to read, so hopefully you can guess at what some of the above logic means. Regardless, let's break down how this works. The first thing we do is create a while(true) loop around our logic. This is a common coroutine pattern, but it can be confusing the first time you see it. In a normal function, an infinite loop would result in the thread soft-locking. However, in coroutines this pattern essentially means "this coroutine will run for the lifetime of the object running it", which is the desired behavior for our enemy AI task.</p>
<p >The next thing we see is the new <code>co_await</code> keyword. The <code>co_await &lt;awaiter&gt;</code> expression, when evaluated, will suspend the current task until the awaiter is ready to be resumed again. In this example we use 3 of the most versatile and powerful awaiters in Squid::Tasks:</p>
<ul>
<li><a class="el" href="struct_suspend.html" title="Awaiter class that suspends unconditionally.">Suspend()</a> -&gt; Waits until the next time the task is resumed (usually a single frame)</li>
<li><a class="el" href="group___awaiters.html#gad09d1c3766b54864b929aef77424e392" title="Awaiter function that waits N seconds in a given time-stream.">WaitSeconds()</a> -&gt; Waits until N seconds have passed in a given time-stream</li>
<li><a class="el" href="group___awaiters.html#ga844758e35c6f1a45e2254deecdfacf98" title="Awaiter function that waits until a given functor returns true.">WaitUntil()</a> -&gt; Waits until a given function returns true</li>
</ul>
<p >With these 3 awaiters, it is possible to implement enormously complex state machines with relatively straightforward code. (To learn about the other awaiters that come with Squid::Tasks, refer to the <a class="el" href="group___awaiters.html">Awaiters</a> documentation.)</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Next Steps</h1>
<p >Hopefully, this brief tutorial has given you an outline of the steps required to integrate coroutines into your own projects. From here, we recommend exploring the "GeneriQuest" sample project under <code>samples/Sample_TextGame</code>. It demonstrates both simple and complex applications of coroutines in a simple text-based game example.</p>
<p >This is the end of the tutorial documentation (for now)! If you made it this far, feel free to write to [tim at giantsquidstudios.com] to let us know any ways in which our documentation could have been more useful for you in learning to use Squid::Tasks!</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Appendices</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
APPENDIX A: Enabling Global Time Support</h2>
<p >Every game project has its own method of updating and measuring game time. Most games feature multiple different "time-streams", such as "game time", "real time", "editor time", "paused time", "audio time", etc... Because of this, the Squid::Tasks library requires each time-sensitive awaiter (e.g. <code><a class="el" href="group___awaiters.html#gad09d1c3766b54864b929aef77424e392" title="Awaiter function that waits N seconds in a given time-stream.">WaitSeconds()</a></code>, <code><a class="el" href="group___awaiters.html#ga85609f2caa4ab4f8ffb82afab66e9add" title="Awaiter function that wraps a given task, canceling it after N seconds in a given time-stream....">Timeout()</a></code>, etc) to be presented with a time-stream function that returns the current time in the desired time-stream. By convention, these time-streams are passed as functions into the final argument of time-sensitive awaiters.</p>
<p >A final (optional) step of integrating Squid::Tasks is to enable global time support and implement a global Squid::GetTime() function.</p>
<p >For less-complex projects it can be desirable to default to a "global time-stream" that removes the requirement to explicitly pass a time-stream function into time-sensitive awaiters. To enable this functionality, the user must set <code>SQUID_ENABLE_GLOBAL_TIME</code> in <a class="el" href="_tasks_config_8h_source.html">TasksConfig.h</a> and implement a special function called Squid::GetTime(). Failure to define this function will result in a linker error.</p>
<p >The Squid::GetTime() function should return a floating-point value representing the number of seconds since the program started running. Here is an example Squid::GetTime() function implementation from within the <code>main.cpp</code> file of a sample project:</p>
<div class="fragment"><div class="line">NAMESPACE_SQUID_BEGIN</div>
<div class="line">tTaskTime GetTime()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (tTaskTime)TimeSystem::GetTime();</div>
<div class="line">}</div>
<div class="line">NAMESPACE_SQUID_END</div>
</div><!-- fragment --><p >It is recommended to save off the current time value at the start of each game frame, returning that saved value from within <code>Squid::GetTime()</code>. The reason for this is that, within a single frame, you likely want all of the tasks to behave as if they are updating at the same time. By providing the same exact time value to all Tasks that are resumed within a given update, the software is more likely to behave in a stable and predictable manner. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
